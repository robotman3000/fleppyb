{"name":"Fleppyb","tagline":"Flexible PowerDNS Python Backend","body":"Fleppyb (Flexible PowerDNS Python Backend)\r\n==========================================\r\n\r\nFleppyb is a [PowerDNS pipe backend][1]. In brief Fleppyb process DNS query from the PowerDNS master process and according with matching rules can resolve the query.\r\nParameters checked during the matching rule process are these provided by the **PipeBackend v.2** protocol:\r\n\r\n**Query Name:** the name whereby the query asks, for example the query performed by\r\n\r\n    dig @192.168.2.20 www.google.it\r\n\r\nthe Query Name will be www.google.it\r\n\r\n**Query Type:** the record type requested by the query, for example:\r\n\r\n    dig @192.168.2.20 -t MX google.it\r\n\r\nthe Query Type will be **MX**\r\n\r\n**Remote IP:** the IP address that performed the query:\r\n\r\n    dig -b 192.168.3.11 @192.168.2.20 -t MX google.it\r\n\r\nthe Remote IP will be **192.168.3.11**\r\n\r\n**Local IP:** the local IP address that received the query:\r\n\r\n    dig @192.168.2.20 www.google.it\r\n\r\nthe Local IP will be **192.168.2.20**\r\n\r\nWith this Fleppyb you can implement a *split brain* configuration or some other match against the query parameters.\r\n\r\nFeatures\r\n========\r\n\r\nAt the moment of writing Fleppyb implements 2 backend:\r\n* **static**: a static backend that allows you to configure your dns answer in a config file, you can also add a dealy in some answers.\r\n* **ldap**: an ldap backend that allow you to be totally independent from your ldap schema, you can use more than one ldap server and configure differents LDAP query for different DNS requests\r\n\r\nConfiguration\r\n=============\r\n\r\nThere is 3 steps:\r\n\r\n1. Configuring Fleppyb parameters\r\n2. Configuring Flappyb matching rules\r\n3. Configuring PowerDNS in order to use Fleppyb as a backend\r\n\r\nConfiguring Fleppyb parameters\r\n----------------------\r\n\r\nYou must edit the main file fleppyb.py configuring these variables: \r\n\r\n* **DEBUG:** enable/disable debugging messages, valid values: **True** or **False**\r\n* **CONFIG_FILE:** path of config file, the config file contains matching rules. Eg. **/etc/powerdns/fleppyb/fleppyb.conf**\r\n* **PARSE_CONFIG_ONCE:** parse the config file once (at startup) or at every query. This parameter can slow down performance in query resolutions. Using *True* you need to restart PowerDNS ad every Fleppyb config file changes. Valid values: **True** or **False**\r\n* **LOGFILE:** where Fleppyb must write logging messages. You can use a file system path or a void value (\"\"). With a void value logging messages will be printed on stdout (useful for testing or debugging). **NB: This file path must exists and must be writable by PowerDNS user**.\r\n\r\nConfiguring query matching\r\n--------------------------\r\n\r\nThe matching rules file (defined bu variable `CONFIG_FILE`) uses [file ini syntax][2]: you must define sections and section variables.\r\n\r\nYou can define a section with name **DEFAULT**: In this section you can define variables that will be inherited by others sections.\r\nVariable defined in **DEFAULT** section can be overwritten in non-default section.\r\n\r\nThe name used in sections define the query matching criteria.\r\nSection name must respect this syntax:\r\n\r\n**[PREC;QUERY_NAME_REGEX:QUERY_TYPE:REMOTE_IP:LOCAL_IP]**\r\n\r\nWhere:\r\n\r\n* **PREC:** is the rule precedence: matching rules is an ordered list, first rule that match with query parameters will be used for the query resolution.\r\n* **QUERY_NAME_REGEX:** it's a regular expression that will be evalued against the *Query Name*. Here you can use the [Python regular expression syntax][3].\r\n* **QUERY_TYPE:** this value will be matched against the *Query Type*, (A, TXT, MX, etc..). You can use the special char * in order to match every query type. \r\n* **REMOTE_IP:** this value will be evaluated against the client IP address requesting the query, can be an IP address or a subnet in CIDR format (Eg.: 192.168.2.0/24)\r\n* **LOCAL_IP:** this value will be evaluated against the destination IP address. Alsto this one can be an IP address or a subnet.\r\n\r\nExamples\r\n--------\r\n\r\n**[1:.*.in-addr\\.arpa$:*:0.0.0.0/0:0.0.0.0/0]** With this section name you define:\r\n\r\n*   **Precedence:** *1*\r\n*   **Query name regex:** \\*.\\*\\.in-addr\\.arpa$ (every name that ends with *in-addr.arpa*)\r\n*   **Query Type:** * (every query type)\r\n*   **Remote IP:** 0.0.0.0/0 (every client IP address)\r\n*   **Local IP:** 0.0.0.0/0 (every server IP address)\r\n\r\nThis section will be evalued as a first rule and will match against every reverse query (every names anding with in-addr.arpa) Ex.:\r\n\r\n    dig @192.168.2.20 -x 192.168.3.10\r\n    \r\n    ;; QUESTION SECTION:\r\n    ;20.2.168.192.in-addr.arpa.\tIN\tPTR\r\n    \r\n    ;; ANSWER SECTION:\r\n    20.2.168.192.in-addr.arpa. 2400\tIN\tPTR\thost.example.com.\r\n\r\nQuery resolution\r\n================\r\n\r\n**Query resolution:**</p> \r\n\r\nInside sections you can define your resolution rules, you can define differents parameters depending on backend used.\r\nIn every sections you must define a **backend** paramether that define the backend. Unltil now only **ldap** and **static** backend are implemented\r\n\r\nStatic Backend\r\n==============\r\nUsing the **static** backend you can statically configure answers for query matching the section. You can define 2 variables:\r\n\r\n* **answer**: this is a three fields value separed by a semicolon (:), these fields must be: TYPE:TTL:VALUE, eg. A:300:192.168.10.100. you can define multiple response separing ansewrs with a comma (,). Eg.: \r\n\r\nThis section define a rule matching every query for the name **host.example.com** with 2 A records with dittents TTL:\r\n\r\n    [10:host\\.example\\.com:*:0.0.0.0/0:0.0.0.0/0]\r\n    backend=static\r\n    answer=A:300:192.168.10.20,A:900:192.168.10.22\r\n\r\nQwering the server:\r\n\r\n    dig @172.16.18.5 host.example.com\r\n\r\n    ;; QUESTION SECTION:\r\n    ;host.example.com.\t\tIN\tA\r\n\r\n    ;; ANSWER SECTION:\r\n    host.example.com.\t900\tIN\tA\t192.168.10.22\r\n    host.example.com.\t300\tIN\tA\t192.168.10.20\r\n\r\n* **delay**: A delay in query response. This is a value in seconds, you can express also decimal values. You can use also random values using rand:MIN:MAX (eg. rand:3:10 will add arandom delay between 3 and 10 sec.)\r\nEg.:\r\n\r\nAdding a 5 seconds delay for every query to host.example.com\r\n\r\n    [10:host\\.example\\.com:*:0.0.0.0/0:0.0.0.0/0]\r\n    delay=5\r\n    backend=static\r\n    answer=A:300:192.168.10.20,A:900:192.168.10.2\r\n\r\nLDAP Backend\r\n============\r\nWith this backend you can implement your DNS server using your own LDAP schema.\r\nWith LDAP Backend you can define for every query matching rule the ldap server, base, credentials, attributes and query filters using these parameters: \r\n\r\n**ldap_uri:** LDAP server URI Eg.: **ldap://localhost**\r\n\r\n**base:** LDAP base used in query Eg.: **dc=example,dc=com**  \r\n**bind_dn:** LDAP bind DN used during the query (if needed). Eg.: **cn=admin.example.com**\r\n**bind_password:** LDAP bind password (if needed)  \r\n**XXX_attribute:** Attribute mapping rule, Eg.: **A_attribute=aRecord** define a mapping between the *A* attribute and the ldap attribute **aRecord** thanks to this field you can use every LDAP schema for your DNS server.\r\n\r\n**Examples:**\r\n    MX_attribute = MxRecord  \r\n    NS_attribute = nSRecord  \r\n    TTL_attribute = dNSTTL  \r\n    SOA_attribute = sOARecord  \r\n    CNAME_attribute = cNAMERecord  \r\n    TXT_attribute = tXTRecord  \r\n\r\n**TTL_default:** default TTL (if **TTL_attribute** isn't defined) \r\n**query**: LDAP query filter. Here you can use some variable extracted from the query (see *Query filter formatting* ) Ex: **(&(objectClass=extensibleObject)(associatedDomain=%(qname)s))**  \r\n**bind:** if False the ldap bind will be not executed. Valid values: **True** or **False**   \r\n\r\n**Query filter formatting:**\r\n\r\nthe **query** parameter can contains some formatters that permit to dinamically compose the ldap query:\r\n\r\n**%(qname)s** : expanded with **Query Name**  \r\n**%(qtype)s** : expandend with **Query Type** \r\n**%(remote_ip)s** : expanded with **Remote IP**  \r\n**%(local_ip)s** : expanded with **Local IP**\r\n**%(rqname)s** : expanded with the IP address representing the *Query Name* if we are resolving a reverse query.\r\n\r\n**Configuring PowerDNS**\r\n\r\nYou neet to add to PowerDNS configuration file (**/etc/powerdns/pdns.conf**) these paramethers:\r\n\r\n   launch=pipe\r\n   pipe-command=/etc/powerdns/fleppyb/fleppyb.py\r\n   pipebackend-abi-version=2\r\n\r\n* **launch=pipe** definisce di utilizzare un pipe backend  \r\n* **pipe-command** definisce il path di fleppyb.py  \r\n* **pipebackend-abi-version=2** definisce la versione del protocollo pipebackend da utilizzare \r\n\r\nExamples\r\n========\r\n\r\nView (split brain) implementation\r\n---------------------------------\r\n\r\nQuery coming from the subnet 192.168.2.0/24 will be used the LDAP tree **dc=internal,dc=example,dc=com**.\r\nAll athers queries will be resolved searching in **dc=external,dc=example,dc=com** ldap tree.\r\n\r\nVery important is the right use of rule precendence!!.\r\n\r\n**fleppyb.ini**\r\n\r\n    [DEFAULT]\r\n    ldap_uri=ldap://localhost\r\n    A_attribute=aRecord\r\n    MX_attribute = MxRecord\r\n    NS_attribute = nSRecord\r\n    TTL_attribute = dNSTTL\r\n    TTL_default = 2400\r\n    SOA_attribute = sOARecord\r\n    CNAME_attribute = cNAMERecord\r\n    base = dc=example,dc=com\r\n    query = (&(objectClass=domainRelatedObject)(associatedDomain=%(qname)s))\r\n    \r\n    [2:.*:*:0.0.0.0/0:0.0.0.0/0]\r\n    TTL_attribute = drink\r\n    base = dc=external,dc=example,dc=com\r\n    query = (dc=%(qname)s)\r\n    backend=ldap\r\n    bind=False\r\n    \r\n    [1:.*:*:192.168.2.50:0.0.0.0/0]\r\n    TTL_attribute = drink\r\n    base = dc=internal,dc=example,dc=com\r\n    query = (dc=%(qname)s)\r\n    backend=ldap\r\n    bind=False\r\n\r\n**Database ldap (tree dc=external,dc=example,dc=com):**\r\n\r\n    dn: dc=external,dc=example,dc=com\r\n    dc: external\r\n    objectClass: top\r\n    objectClass: dcObject\r\n    objectClass: organization\r\n    o: 2v\r\n    \r\n    dn: dc=example.com,dc=external,dc=example,dc=com\r\n    sOARecord: ns1.example.com. dns-admin.example.com. 1446303 7200 1800 1209600 300\r\n    dc: example.com\r\n    objectClass: dNSDomain\r\n    objectClass: domain\r\n    objectClass: top\r\n    nSRecord: ns1.example.com.\r\n    nSRecord: ns2.example.com.\r\n    \r\n    dn: dc=ns1.example.com,dc=external,dc=example,dc=com\r\n    dc: ns1.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 83.102.11.30\r\n    \r\n    dn: dc=ns2.example.com,dc=external,dc=example,dc=com\r\n    dc: ns2.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 83.102.11.31\r\n    \r\n    dn: dc=www.example.com,dc=external,dc=example,dc=com\r\n    dc: www.example.com\r\n    cNAMERecord: fast.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    \r\n    dn: dc=fast.example.com,dc=external,dc=example,dc=com\r\n    dc: fast.example.com\r\n    drink: 60\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 83.102.11.32\r\n\r\n**Dadabase ldap (tree dc=internal,dc=example,dc=com)**\r\n\r\n    dn: dc=internal,dc=example,dc=com\r\n    dc: internal\r\n    objectClass: top\r\n    objectClass: dcObject\r\n    objectClass: organization\r\n    o: 2v\r\n    \r\n    dn: dc=example.com,dc=internal,dc=example,dc=com\r\n    sOARecord: ns1.example.com. dns-admin.example.com. 1446303 7200 1800 1209600 300\r\n    dc: example.com\r\n    objectClass: dNSDomain\r\n    objectClass: domain\r\n    objectClass: top\r\n    nSRecord: ns1.example.com.\r\n    nSRecord: ns2.example.com.\r\n    \r\n    dn: dc=ns1.example.com,dc=internal,dc=example,dc=com\r\n    dc: ns1.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 192.168.101.2\r\n    \r\n    dn: dc=ns2.example.com,dc=internal,dc=example,dc=com\r\n    dc: ns2.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 192.168.101.1\r\n    \r\n    dn: dc=www.example.com,dc=internal,dc=example,dc=com\r\n    dc: www.example.com\r\n    cNAMERecord: fast.example.com\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    \r\n    dn: dc=fast.example.com,dc=internal,dc=example,dc=com\r\n    dc: fast.example.com\r\n    drink: 60\r\n    objectClass: dcObject\r\n    objectClass: top\r\n    objectClass: organization\r\n    objectClass: extensibleObject\r\n    o: example.com\r\n    aRecord: 192.168.101.3\r\n\r\n**Query coming from an IP not in 192.168.2.0/24 subnet**\r\n\r\n    dig @192.168.2.20 -b 192.168.3.20 www.example.com\r\n    \r\n    ;; QUESTION SECTION:\r\n    ;www.example.com.               IN      A\r\n    \r\n    ;; ANSWER SECTION:\r\n    www.example.com.        2400    IN      CNAME   fast.example.com.\r\n    fast.example.com.       60      IN      A       83.102.11.32\r\n\r\n**Query coming from the interna subnet (192.168.2.0/24)**\r\n\r\n    dig @192.168.2.20 -b 192.168.2.50 www.example.com\r\n    \r\n    ;; QUESTION SECTION:\r\n    ;www.example.com.               IN      A\r\n    \r\n;; ANSWER SECTION:\r\n    www.example.com.        2400    IN      CNAME   fast.example.com.\r\n    fast.example.com.       60      IN      A       192.168.101.3\r\n\r\nReverse zone\r\n------------\r\n\r\nIf a query with type **ANY** or **PTR** asks for a name that ends with in-addr.arpa the formatter **%(rqname)** will be resolved with the IP address.\r\n\r\nEx:\r\n\r\n**dig -t ANY -x 192.168.2.20**\r\n\r\nthis command executes a query with type ANY and name 20.2.168.192.in-addr.arpa \r\n**%(rqname)s will be resolved with 192.168.2.20**\r\n\r\nExample:\r\n\r\n**fleppyb.ini**\r\n\r\n    [DEFAULT]\r\n    ldap_uri=ldap://localhost\r\n    ;bind_dn=cn=admin,dc=example,dc=com\r\n    ;bind_password=changeme\r\n    A_attribute = aRecord\r\n    MX_attribute = MxRecord\r\n    NS_attribute = nSRecord\r\n    TTL_attribute = dNSTTL\r\n    ; the default value for TTL\r\n    TTL_default = 2400\r\n    SOA_attribute = sOARecord\r\n    CNAME_attribute = cNAMERecord\r\n    base = dc=example,dc=com\r\n    query = (&(objectClass=extensibleObject)(associatedDomain=%(qname)s))\r\n    \r\n    [2:.*:*:0.0.0.0/0:0.0.0.0/0]\r\n    base = dc=netconf,dc=example,dc=com\r\n    query = (&(objectclass=extensibleObject)(associatedDomain=%(qname)s))\r\n    backend=ldap\r\n    bind=False\r\n    autogen_ptr=True\r\n    \r\n    [1:.*.in-addr\\.arpa:*:0.0.0.0/0:0.0.0.0/0]\r\n    base = dc=netconf,dc=example,dc=com\r\n    query = (&(objectclass=extensibleObject)(arecord=%(rqname)s))\r\n    backend=ldap\r\n    bind=False\r\n    PTR_attribute=associatedDomain\r\n\r\n**Reverse query:**   \r\n\r\n    dig -x 192.168.2.20)\r\n    \r\n   ;; QUESTION SECTION:\r\n    ;20.2.168.192.in-addr.arpa.     IN      PTR\r\n    \r\n    ;; ANSWER SECTION:\r\n    20.2.168.192.in-addr.arpa. 2400 IN      PTR     www.example.com.\r\n\r\nPowerDNS and caching\r\n====================\r\n\r\nIf you configure Fleppyb in order to provide differents answers for the same name (Ex. split brain configuration) you need to disable query caching in PowerDNS configuring query-cache-ttl e negquery-cache-ttl at 0.\r\nYou can leave enable the cache-ttl.\r\n\r\nTesting\r\n\r\nYou can manually testing fleppy simulating the PIPE backend protocol:\r\n\r\n    echo -ne \"HELO\\nQ\\t20.2.168.192.in-addr.arpa\\tIN\\tANY\\t-1\\t192.168.3.13\\t0.0.0.0\" | /etc/powerdns/fleppyb/fleppyb.py\r\n\r\n\r\n [1]: http://doc.powerdns.com/backends-detail.html#pipebackend\r\n [2]: http://docs.python.org/2/library/configparser.html\r\n [3]: http://docs.python.org/2/library/re.html\r\n\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/pbertera/fleppyb/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}